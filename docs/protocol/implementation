\section{Platform}
\subsection{Initialization}
\noindent
The platform initialization depends on the settings of a nodes makefile and on the data provided by the Application developer.
The settings of a nodes makefile influence the set of hardware services available to the specific platform. When a node is
linked to some hardware drivers supported by the platform e.g. bargraph, the according makefile will compile the platform code
with a C preprocessor setting -DBARGRAPH. The platform will only support those drivers for which C preprocessor defines where made,
by inspecting the defines and only assigning the driver function pointers supported. This allows for simple adaptation and extension
of the platform by changing the drivers linked to the platform. Additionally by choosing this approach a smaller size of the executable
is achieved.\\

\begin{figure}[!htb]
%\lstset{language=make}
\begin{lstlisting}[frame=single]

# put platform specific hardware drivers to be supported by this node
OBJ-ESEL-MDEP-$(MNAME)-y += protocol0 bargraph

\end{lstlisting}
\caption{Platform makefile}
\label{fig:platform-makefile}
\end{figure}

\noindent
The makefile snippet from the figure shown above will result in a compilation of the 
platform with the setting -DPROTOCOL0 -DBARGRAPH.\\

\noindent
The initialization code of the platform checks for these defines and only registers and initializes those drivers supported as shown in
the figure below.

\begin{figure}[!htb]
%\lstset{language=C}
\begin{lstlisting}[frame=single]

#ifdef BARGRAPH
	bargraph_init();
	platform.drivers.set_bargraph = set_bargraph;
#endif

#ifdef PROTOCOL0
	 protocol_init(platform.id, recv_handler);
#endif

\end{lstlisting}
\caption{Platform drivers initialization}
\label{fig:platform-init}
\end{figure}

\noindent
Additionally the agents to be executed need to be initialized on the platform by the application developer.
This is achieved by providing C macros to the application developer which need to be filled with proper data.
The C macros offered by the platform are shown in the figure below. \\

\begin{figure}[!htb]
\lstset{language=C, tabsize=2}
\begin{lstlisting}[frame=single]

#include "platform.h"

PLATFORM_CONFIGURATION()
{
	AGENTS_CONFIGURATION(){
		 // agent id, agent prio, agent_code
		 AGENT_INIT(0x02, 0x02, 0000011100000001111110
		 001101000100000101000111100100000000000001111
		 1001111111011),
	},
	
	BOARD_ID(0x00)
};

\end{lstlisting}
\caption{Platform agent initialization}
\label{fig:platform-agent-init}
\end{figure}

\noindent
The AGENT_INIT macro needs to be defined by the application developer in order to instantiate an agent.
As its input parameters it requires the agent id, agent priority and a binary string representing the agent
code, which is delivered by the platform assembler tool (asm_agent). During platform initialization the binary
string is converted to a binary representation in order to reduce the actual code size.
Up to 4 agents can be initialized. All configured agents are assigned the status ready.

Additionally the application developer is able to initialize the board id,
required for inter board communication via the BOARD_ID macro.

\subsection{Execution}
After successfull platform intialization the scheduler iterates through the configured agents i.e. those with status ready and forwards them to
the execution layer to be executed via the method execute_agent shown in figure~\ref{fig:platform-agent-exec} on page~\pageref{fig:platform-agent-exec}.\\

\begin{figure}[!htb]
\lstset{language=C, tabsize=2}
\begin{lstlisting}[frame=single]

uint8_t execute_agent(agent_t *agent, uint8_t opcode_size) {

	uint8_t opcodes_done = 0;

	while (opcodes_done < opcode_size) {
		//1. fetch next opcode
		uint16_t opcode = agent->code[agent->pc];

		//2. decode opcode
		opcode_t dec_opcode = decode_opcode(opcode);

		//3. execute opcode
		execute_opcode(agent, dec_opcode);

		//4. increase program counter
		if (agent->status == ready) {
			if (agent->pc < agent->code_len - 1 || agent->pc == 0xffff) {
				agent->pc += 1;
			} else {
				agent->status = stopped;
				break;
			}
			opcodes_done += 1;
		} else {
			return opcodes_done;
		}

	}

	return opcodes_done;
}

\end{lstlisting}
\caption{Platform agent execution}
\label{fig:platform-agent-exec}
\end{figure}


\noindent
The execution layer fetches the next opcode for the considered agent, decodes the according and finally executes the specific 
opcode. Eventually the program counter is increased and the next opcode gets executed. The execution of an agent is stopped
as soon as the desired amount of opcode has been executed or if an agent was put to a different status than ready.\\

\noindent
The decoding of the agent opcodes is performed by analyzing the 8 bit opcode header of the total 16 bit opcode as exemplarily
shown in figure~\ref{fig:platform-agent-opcode-dec} on page~\pageref{fig:platform-agent-opcode-dec}.\\

\begin{figure}[!htb]
\lstset{language=C, tabsize=2}
\begin{lstlisting}[frame=single]

	uint8_t nibble1 = NIBBLE1(opcode);
	uint8_t nibble2 = NIBBLE2(opcode);

	switch (nibble1) {
	//0000
	case 0:
		switch (nibble2) {

		//clr reg_str
		//0000 0010 0000 rrrr
		case 2:
			result.id = CLEAR;
			result.reg1 = NIBBLE4(opcode);
			break;

		//add reg_d, reg_r
		//0000 0011 dddd rrrr
		case 3:
			 result.id = ADD_R;
			 result.reg1 = NIBBLE3(opcode);
			 result.reg2 = NIBBLE4(opcode);
			break;


\end{lstlisting}
\caption{Platform agent opcode decoding}
\label{fig:platform-agent-opcode-dec}
\end{figure}

\noindent
Finally the opcode gets executed and agent configuration structure is updated as shown in figure~\ref{fig:platform-agent-opcode-exec} on page~\pageref{fig:platform-agent-opcode-exec}.\\

\begin{figure}[!htb]
\lstset{language=C, tabsize=2}
\begin{lstlisting}[frame=single]
	
	case JMP_G:
		PRINTF("jmpgr offset:%d\n", opcode.value);
		if (agent->regs[REG_ACC]==1) {
			agent->pc = agent->pc + opcode.value;
		}
		break;

	case JMP_E:
		PRINTF("jmpeq offset:%d\n", opcode.value);
		if (agent->regs[REG_ACC]==0){
			agent->pc = agent->pc + opcode.value;
		}
		break;

	case JMP_L:
		PRINTF("jmpls offset:%d\n", opcode.value);
		if (agent->regs[REG_ACC]==-1){
			agent->pc = agent->pc + opcode.value;
		}
		break;

\end{lstlisting}
\caption{Platform agent opcode execution}
\label{fig:platform-agent-opcode-exec}
\end{figure}

\noindent
After all opcodes of an agent have been executed or the according agent was stopped the scheduler looks for the next agent with status ready
to be executed. 

\subsection{Communication}
The communication layer provides means to send and receive messages via the USART serial bus. The lower level implementation of
the CSMA/CA protocol allows up to 15 bytes of payload to be transferred with a single message. Due to this limitation an upper layer
protocol is introduced which allows greater messages to be exchanged between nodes. \\

\noindent
This protocol works with frames, where a frame is split into a sufficient amount of packets which are transmitted via the serial bus 
sequentially. In order to increase data throughput 2 types of packages were introduced: start packages and data packages.\\

\noindent
The start packages always initialize the sending of a new frame and contain all the necessary data to succesfully address 
the destination of the packet and inform the receiver about specific frame settings i.e. frame id and frame length. 
Figure~\ref{fig:start} on page~\pageref{fig:start} shows the layout of start packages.\\

\begin{table}
\centering
\begin{tabular}{| c | c |}
  \hline
  dst_node &packet len \\ \hline
  start_type & 	src board \\ \hline
  src_node	&	frame id \\ \hline
  \multicolumn{2}{|c|}{packet id hi} \\ \hline
  \multicolumn{2}{|c|}{packet id low} \\ \hline
  dst board	&	dst agent \\ \hline
  \multicolumn{2}{|c|}{frame length hi} \\ \hline
  \multicolumn{2}{|c|}{frame length low} \\ \hline
  \multicolumn{2}{|c|}{data} \\ \hline
  \multicolumn{2}{|c|}{...} \\ \hline
  \multicolumn{2}{|c|}{crc} \\ \hline
  
\end{tabular}
\label{fig:start}
\caption{Start Package}
\end{table}


\noindent
The data packages are only used when a frame payload is greater than the 15 byte which can be sent within a single packet.
These data packages identify the frame to which the belong and are able to transmit more payload data within a package.
Figure~\ref{fig:data} on page~\pageref{fig:data} shows the layout of data packages.\\\\

\begin{table}
\centering
\begin{tabular}{| c | c |}
  \hline
  dst_node &packet len \\ \hline
  start_type & 	src board \\ \hline
  src_node	&	frame id \\ \hline
  \multicolumn{2}{|c|}{packet id hi} \\ \hline
  \multicolumn{2}{|c|}{packet id low} \\ \hline
  \multicolumn{2}{|c|}{data} \\ \hline
  \multicolumn{2}{|c|}{...} \\ \hline
  \multicolumn{2}{|c|}{crc} \\ \hline
  
\end{tabular}
\caption{Data Package}
\label{fig:data}
\end{table}

\noindent
The receiving platform of the communication reassembles the received packets into a single frame prior to informing the
according agent about this event. \\

\subsection{Code Mobility}

In order to provide means for code mobility a localization service is introduced which allows identifying the hardware
supported by a specific node. This is achieved by a static array storing the addresses of the nodes supporting a specific hardware as shown in
figure~\ref{fig:service-loc} on page~\pageref{fig:service-loc}. This localization is only valid for the current ESE board and requires
adaptation when porting the platform to another board.\\

\begin{figure}[!htb]
\lstset{language=C, tabsize=2}
\begin{lstlisting}[frame=single]
	
uint8_t service_locations[MAX_SERVICE][MAX_NODES] = {
			{NODE0_ID, NODE1_ID, INVALID, INVALID},	 //BARGRAPH
			{NODE1_ID, INVALID, INVALID, INVALID}, 	 //THERMOMETER
			{NODE1_ID, INVALID, INVALID, INVALID},	 //COOLER
			{NODE1_ID, INVALID, INVALID, INVALID},   //HEATER
			{NODE3_ID, INVALID, INVALID, INVALID},   //LED
			{NODE2_ID, INVALID, INVALID, INVALID},   //LCD
			{NODE0_ID, NODE1_ID, NODE2_ID, NODE3_ID} //BUTTONS
};
\end{lstlisting}
\caption{Service localization}
\label{fig:service-loc}
\end{figure}

After the address of the receiving board has been identified, the agent is serialized via the serialiaze_agent method. 
A frame containing a code mobility message is marked by a code mobility header and trailer (0x55).\\

\noindent
When a complete frame has been received by a platform it checks whether this is a data message or code mobility message
by inspecting the first(header) and last(trailer) byte of the received message. If a code mobility message was received
the platform deserializes the agent, increments its program counter by 1 and instantiate this very agent within the platform
so its considered for execution during the next scheduling round. \\

\begin{figure}[!htb]
\lstset{language=C, tabsize=2}
\begin{lstlisting}[frame=single]
	
if (GET_MOBILITY_HEADER(current->data) == MOBILITY_BYTE && 
				GET_MOBILITY_END(current->data, current->frame_length - 1)
				== MOBILITY_BYTE){
	//code mobility message

	for (i = 0; i < AGENT_MAX; i++){
		if (platform.agents[i].status == stopped){
			agent_t agent = deserialize_agent(current->data);
			agent.id = id;
			agent.regs[REG_ACC] = 0;
			agent.pc+= 1;
			platform.agents[i] = agent;
			break;
		}
	}

\end{lstlisting}
\caption{Agent deserialization}
\label{fig:agent-des}
\end{figure}


\noindent
In order to allow to distinguish whether the agent 
was moved or is the initiatior of the moving, the receving platform writes a 0 to accumulator of the received agent,
whereas the sending platform writes the amount of sent packets to the accumulator of the sending agent. 


